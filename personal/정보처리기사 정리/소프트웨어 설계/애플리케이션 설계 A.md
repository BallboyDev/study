# 소프트웨어 아키텍처
## 소프트웨어 아키텍처란?
- 소프트웨어의 골격이 되는 기본 구조
- 소프트웨어를 구성하는 요소들 간의 관계를 표현
- 소프트웨어 개발 시 적용되는 원칙과 지침
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등 결정
- 기본 원리 
    - 모듈화
        - 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리가 용이하도록 시스템의 기능들을 모듈단위로 나누는 것
    - 추상화
        - 문제의 전체적이고 포괄적인 개념을 설계 후 차례로 세분화하여 구체적으로 제작
        - 추상화는 최소의 비용으로 실제의 상황에 대처할 수 있고 시스템의 구조 및 구성을 대략적으로 파악
        - 유형
            - 과정추상화 : 전반적인 흐름만 파악
            - 데이터 추상화 : 데이터 구조를 대표할 수 있는 표현
            - 제어 추상화 : 이벤트 발생을 대표할 수 있는 표현
    - 단계적 분해
        - 하향식 설계 전략
        - 상위 계념 부터 하위 계념으로 구체화 시키는 분할 기법
    - 정보은닉
        - 모듈 내부의 포함된 절차와 자료 정보를 감추어서 다른 모듈이 접근하지 못하도록 하는 기법
        - 각각의 모듈들을 독립적으로 수행
        - 하나의 모듈이 변경및 삭제 되더라도 다른 모듈에 영향을 미치지 않음

## 소프트웨어 아키텍처의 품질 속성
- 시스템 측면
    - 성능
    - 보안
    - 가용성 - 장애 없이 정상적인 서비스 제공
    - 기능성 - 사용자가 요구한 기능 제공
    - 사용성
    - 변경용이성
    - 확정성
    - 기타 속성(테스트 용이성, 배치성, 안전성 등)
- 비즈니스 측면
    - 시장 적시성 - 정해진 시간에 맞추어 프로그램 출시 (공수 일자)
    - 비용 해택 - 유지 보수
    - 예상 시스템 수명 - 시스템 사용 기간
    - 기타 속성(목표 시장, 공개 일정, 기존 시스템과의 통합 등)
- 아키텍처 측면
    - 개념적 무결성 - 전체 시스템과 시스템을 이루는 구성 요소간의 일관성
    - 정확성
    - 완결성
    - 구축 가능성 - 모듈 단위로 구분되어 있는 시스템을 적절할게 분배하고 유연하게 일정을 변경
    - 기타 속성(변경성, 시험성, 적응성, 일치성, 대체성 등)

## 설계 과정
1. 설계 목표 설정
    - 사용자와 시스템의 요구사항을 분석하여 전체 시스템의 설계 목표 설정
2. 시스템 타입 결정
    - 대화형 시스템 - 사용자 요구 발생 시 시스템이 처리하고 반응하는 시스템
    - 이벤트 중심 시스템 - 외부의 상태 변화에 따라 동작하는 시스템
    - 변환형 시스템 - 데이터 입력 시 작업을 수행하여 결과를 출력하는 시스템
    - 객체 영속형 시스템 - 데티어 베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템
3. 아키텍처 패턴 적용
    - 여러 다양한 상황에서 발생하는 문제점을 해결하기 위한 미리 만들어 놓은 전형적인 해결 방법
4. 서브 시스템 구체화
    - 서브 시스템 기능 및 서브 시스템 간의 상호 작용을 위한 동작과 인터페이스 정의
5. 검토
    - 아키텍처의 설계 목표에 부합, 요구사항 반영 여부, 설계 기본 원리 만족 등 검토

# 아키텍처 패턴
## 개요
- 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽 제시
- 아키텍처 패턴 = 아키텍처 스타일 = 표준 아키텍처
- 아키텍처 패턴의 장점
    - 시행착오를 줄여 개발시간을 단축시키고, 고품질의 소프트웨어 생산이 가능
    - 검증된 구조로 개발하기 때문에 안정적인 개발이 가능
    - 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해짐
    - 시스템의 구조를 이해하는 것이 쉬움 (개발에 참여하지 않은 사람도 유지 보수 수행이 가능)\
    - 시스템의 특성을 개발 전에 예측하는 것이 가능해짐

## 종류
1. 레이어 패턴 
    - 시스템을 계층 으로 구분하여 구성하는 고전적인 방법중의 하나
    - 대표적으로 OSI 7계층 참조 모델
    - 서로 연결된 두 객채간에만 영향을 미치기 때문에 전체적인 독립성 보장
    - 특정 계층만 교체해 시스템 변경이 가능
2. 클라이언트 - 서버 패턴
    - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
3. 파이프 - 필터 패턴
    - 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화 하여 파이프를 통해 데이터를 전송하는 패턴
    - 데이터 스트림 : 데이터가 송수신 되거나 처리되는 일련의 연속적인 흐름
    - 필터 컴포넌트들은 재사용성이 좋고 추가가 쉬워 확장이 용이함
    - 데이터를 변환하거나 버퍼를 동기화할때 사용
    - 대표적으로 유닉스 쉘(shell)
4. 모델 - 뷰 - 컨트롤러 패턴 (MVC pattern)
    - 서브시스템을 3개의 부분으로 구조화 하는 패턴
    - 모델: 서브시스템을 핵심기능과 데이터를 보관함
    - 뷰: 사용자에게 정보를 표시함
    - 컨트롤러: 사용자로부터 받은 입력을 처리함
    - 대화용 어플리케이션 (쇼핑몰 사이트 등)
5. 기타 패턴
    - 마스터 - 슬레이브 패턴
        - 마스터 컨포넌트에서 슬레이브 컴포넌트로 작업을 분활한후 슬레이브에서 처리된 데이터 결과를 다시 받는 패턴
        - 장애 허용 시스템, 병렬 연결 시스템
    - 브로커 패턴
        - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청을 하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴
        - 분산 환경 시스템 
    - 피어 - to - 피어 패턴
        - 피어를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
    - 이벤트 - 버스 패턴
        - 소스가 특정 채널에 이벤트 메시지를 발행하면 해당 채널을 구독한 리스너들이 메시지를 받아서 이벤트 형식으로 처리하는 패턴
    - 블랙보드 패턴
        - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로 컴포넌트들은 검색을 통하여 블랙보드에서 원하는 데이터를 찾을 수 있는 형태
        - 음성인식, 차량식별, 신호해석 등
    - 인터프리터 패턴
        - 프로그램의 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴
        - 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계 할 때 사용

# 객체지향
## 객체지향이란?
- 현실세계의 객체를 기계의 부품처럼 하나의 객체로 만들어 부품을 조립하듯이 객체를 조립해서 프로그램을 제작하는 기법
- 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용됨
    - 개발 공정에만 집중, 유지보수 어렵고, 추가 요구사항에 대응 어렵고, 재사용이 어려움
    - C언어와 같이 절차적인 함수들로만 이루어진 프로그램 개발 기법
- 장점
    1. 소프트웨어의 재사용 및 확장 용이
    2. 고품질의 소프트웨어를 빠르게 개발가능
    3. 유지보수 용이
- 주요 구성 요소
    - 객체 (Object)
    - 클래스 (Class)
    - 캡슐화 (Encapsulation)
    - 상속 (inheritance)
    - 다형성 (Polymorphism)

## 객체(Object)
- 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화) 하나의 소프트웨어 모듈
    - 데이터
        - 객체가 가지고 있는 정보 (속성, 상태, 분류 등)
        - 속성, 상태, 변수, 상수, 자료구조
    - 함수 
        - 객체가 갖는 데이터를 처리하는 알고리즘
        - 메소드, 서빗, 동작, 연산
- 특성
    1. 독립적으로 식별 가능한 이름을 가지고 있음
    2. 상태는 시간에 따라 변함
    3. 객체와 객체는 상효 연관성에 의한 관계가 형성됨
    4. 메시지 집합을 행위라고 하며, 객체는 행위의 특징을 나타냄
    5. 객체는 일정한 기억 장소를 가지고 있음
- 객체의 메소드는 다른 객체로부터 메시지(호출)를 받았을 떄 기능 수행
    - 구조적 기법
        - 프로그램 = 데이터 + 함수
    - 객체지향 기법
        - 객체 = 데이터 + 함수
        - 프로그램 = 객체 + 객체

## 클래스(class)
- 공통된 속성과 연산(행위)를 갖는 개체의 집합
- 인스턴스(Instance): 클래스에 속한 각각의 객체
- 인스턴스화(Instantiation): 클래스로 부터 새로운 객체를 생성하는 것
- 슈퍼클래스(Superclass): 특정 클래스의 상위(부모)클래스
- 서브클래스(SubClass): 특정 클래스의 하위(자식)클래스

## 캡슐화(Encapsulation)
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶은 것
- 캡슐화된 객체들은 인터페이스를 제외하고는 세부내용이 은폐되어 외부에서 접근이 제한적이어서 외부 모듈의 변경으로 인한 파급효과가 적다
- 보안, 정보 은닉, 독립성
- 캡슐화된 객체들은 재사용이 용이
- 인터페이스가 단순해지고, 객체 간의 결합도 낮아짐

## 상속(Inheritance)
- 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스가 물려 받는것
- 객체와 클래스의 재사용(소프트웨어의 재사용)을 높이는 중요한 개념
- 다중 상속(Mulit Inheritance)

## 다형성(Polymorphism)
- 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함
- 응용 프로그램 상에서 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스 처럼 수행할 수 있도록 하는 것

# 모듈
## 모듈이란?
- 모듈화를 통해 분리된 시스템의 각 기능들
- 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위등
- 단독으로 컴파일 가능, 재사용 가능
- 독립성, 소프트웨어를 구성하는 각 모듈의 기능이 독립됨을 의미
- 모듈이 하나의 기능만을 수행하고 다른 모듈간의 과도한 상호작용이 배제됨
- 결합도↓, 응집도↑

## 결합도
- 모듈간의 상호 의존하는 정도 또는 두 모듈 사이의 연관관계
- 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음
- 결합도가 강하면 시스템 구현, 유지보수 작업이 어려움
- 자료 결합도 > 스탬프 결합도 > 제어 결합도 > 외부 결합도 > 공통 결합도 > 내용 결합도
    - 자료 결합도
        - 모듈간의 인터페이스가 자료 요소로만 구성될 때의 결합도
        - 모듈간의 내용을 전혀 알 필요가 없는 상태
        - 한 모듈의 내용을 변경하더라도 다른 모듈에는 영향을 미치지 않는 결합도
    - 스탬프 결합도
        - 모듈간의 인터페이스
        - 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합도
    - 제어 결합도
        - 다른 모듈내부의 논리적인 흐름을 제어 하기 위하여 제어신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도
        - 제어요소 : function, code, switch, tag, flag
        - 하위 모듈에서 상위모듈로 제어 신호를 전달하여 하위 모듈이 상위 모듈에게 다시 처리 명령을 내리는 권리 전도 현상 발생 할 수 있음 
    - 외부 결합도
        - 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
    - 공통 결합도
        - 공유되는 공통 데이터 영역을 여러 모듈이 함께 사용할 때의 결합도
        - 공통 데이터의 정보가 조금만 바뀌더라도 여러 모듈에 영향을 미침
        - 모듈의 독립성을 약하게 만듬
    - 내용 결합도
        - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
        - 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우

## 응집도
- 정보 은닉 개념을 확장한 것
- 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도
즉 모듈이 독립적인 기능으로 정의 되어 있는 정도를 의미
- 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음
- 기능적 응집도 > 순차적 응집도 > 교환적 응집도 > 절차적 응집도 > 시간적 응집도 > 논리적 응집도 > 우연적 응집도
    - 기능적 응집도
        - 모듈 내부의 모든 기능요소들이 단일 문제와 연관되어 수행될 경우
    - 순차적 응집도
        - 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
    - 교환적 응집도
        - 동일한 입력 출력을 사용하여 서로 다른 기능을 수행하는 구성요소들이 모여 있을 경우 
    - 절차적 응집도
        - 모듈이 다수의 관련기능을 가질 대 모듈의 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
    - 시간적 응집도
        - 특정 시간에 처리되는 몇개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
    - 논리적 응집도
        - 유사한 셩격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
    - 우연적 응집도
        - 모듈 내부의 각 구성요소들이 서로 관련 없는 요소들로만 이루어진 경우의 응집도

## 팬인(Fan-in) / 팬아웃(Fan-out)
- 팬인: 어떤 모듈을 제어(호출)하는 모듈의 수 => 특정모듈로 들어오는 수
- 팬아웃: 어떤 모듈에 의해 제어(호출)되는 모듈의 수 => 특정모듈에서 나가는 수
- 시스템의 복잡도를 최적화하려면 팬인은 높게 팬아웃은 낮게 설계 해야 함